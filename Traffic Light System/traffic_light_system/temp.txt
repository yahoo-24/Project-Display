Package name
|
|_ config
|     |_  1 config file (e.g., params.yaml)
|
|_ launch
|     |_ main_launch.py                 # Existing launch file
|     |_ gazebo_launch.py              # NEW: Launch file to start Gazebo
|     |_ robot_spawn_launch.py         # NEW: Launch file to spawn robot into Gazebo
|
|_ resource
|     |_ <resource files>              # Likely stays unchanged
|
|_ test
|     |_ <your test files>
|
|_ <package_name>/
|     |_ *.py                          # Your existing Python nodes
|
|_ description/                        # ✅ NEW: Holds robot model and meshes
|     |_ urdf/
|         |_ robot.urdf.xacro          # NEW: Your robot model
|     |_ meshes/
|         |_ *.dae / *.stl             # NEW: Meshes if needed
|
|_ worlds/                             # ✅ NEW: Gazebo world files
|     |_ custom_world.world            # NEW: Custom Gazebo world (optional)
|
|_ rviz/                               # ✅ NEW (optional): RViz configs
|     |_ robot_sim.rviz
|
|_ package.xml                         # Update with dependencies (see below)
|_ setup.py
|_ setup.cfg


<exec_depend>gazebo_ros</exec_depend>
<exec_depend>ros2launch</exec_depend>
<exec_depend>robot_state_publisher</exec_depend>
<exec_depend>joint_state_publisher</exec_depend>
<exec_depend>xacro</exec_depend>


GAZEBO LAUNCH

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([FindPackageShare('gazebo_ros'), 'launch', 'gazebo.launch.py'])
        ])
    )

    return LaunchDescription([gazebo])


ROBOT SPAWN LAUNCH

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import ExecuteProcess
from launch.substitutions import Command, PathJoinSubstitution
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    urdf_file = PathJoinSubstitution([
        FindPackageShare('<package_name>'), 'description', 'urdf', 'robot.urdf.xacro'
    ])

    robot_description = {'robot_description': Command(['xacro ', urdf_file])}

    return LaunchDescription([
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            parameters=[robot_description]
        ),
        ExecuteProcess(
            cmd=[
                'ros2', 'run', 'gazebo_ros', 'spawn_entity.py',
                '-topic', 'robot_description',
                '-entity', 'my_robot'
            ],
            output='screen'
        )
    ])


import rclpy
from rclpy.node import Node
from std_srvs.srv import Empty  # not used here, but an example if you want to add services
import subprocess
import time


class ConditionalSpawner(Node):
    def __init__(self):
        super().__init__('conditional_spawner')

        # Your condition variable
        self.x = 0

        # Timer to check the condition every second
        self.create_timer(1.0, self.check_condition)

    def check_condition(self):
        # Change the value of self.x however you want
        self.x += 1
        self.get_logger().info(f'Checking condition: x = {self.x}')

        if self.x == 5:
            self.spawn_entity('/absolute/path/to/your_model.sdf', 'my_model', 0, 0, 0)

    def spawn_entity(self, sdf_path, entity_name, x, y, z):
        with open(sdf_path, 'r') as f:
            sdf_content = f.read()

        # Use subprocess to call the equivalent of `ros2 run ros_gz_sim create`
        cmd = [
            'ros2', 'run', 'ros_gz_sim', 'create',
            '-string', sdf_content,
            '-name', entity_name,
            '-x', str(x), '-y', str(y), '-z', str(z)
        ]

        self.get_logger().info(f"Spawning entity: {entity_name}")
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            self.get_logger().info(f"Spawn successful: {result.stdout}")
        except subprocess.CalledProcessError as e:
            self.get_logger().error(f"Failed to spawn: {e.stderr}")


def main():
    rclpy.init()
    node = ConditionalSpawner()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()



ros2 run ros_gz_sim create -file /src/traffic_light_system/description/sdf/car.sdf -name my_model_2 -x 5 -y 5 -z 1



import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SpawnEntity

class Spawner(Node):
    def __init__(self):
        super().__init__('entity_spawner')
        self.cli = self.create_client(SpawnEntity, '/spawn_entity')

    def ...
        self.req = SpawnEntity.Request()
        self.req.name = 'my_robot'
        self.req.xml = open('/path/to/your/model.sdf', 'r').read()
        self.req.robot_namespace = ''
        self.req.reference_frame = 'world'
        self.req.initial_pose.position.x = 1.0
        self.req.initial_pose.position.y = 0.0
        self.req.initial_pose.position.z = 0.5

        self.future = self.cli.call_async(self.req)






export GZ_SIM_SYSTEM_PLUGIN_PATH=~/ros_gz_ws/install/ros_gz_sim/lib/